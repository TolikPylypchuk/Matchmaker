{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Matchmaker API | Matchmaker",
    "summary": "Matchmaker API This section contains API docs for the Matchmaker package. Use the sidebar to navigate the API documentation."
  },
  "articles/async.html": {
    "href": "articles/async.html",
    "title": "Asynchronous Pattern Matching | Matchmaker",
    "summary": "Asynchronous Pattern Matching Starting with version 3.0, asynchronous pattern matching is also available. Important On .NET Standard 2.0, Matchmaker uses Microsoft.Bcl.AsyncInterfaces as the polyfill for asynchronous interfaces. Async Patterns Async patterns are objects which implement the Matchmaker.Patterns.Async.IAsyncPattern<TInput, TMatchResult> interface. They are very similar to normal patterns, except they are matched asynchronously. The interface contains two members: string Description { get; } Task<MatchResult<TMatchResult>> MatchAsync(Tinput input); The predefined patterns (contained in the Matchmaker.Patterns.Async.AsyncPattern class) and extension methods from MatchMaker.Linq are basically the same. There are also extensions for Task<MatchResult<TMatchResult>>. The only difference is that the Cached extension method returns a pattern which caches its inputs in a thread-safe manner. Creating custom async patterns is also basically the same as creating custom patterns: you can use the CreatePattern methods from the AsyncPattern class, extend the Matchmaker.Patterns.Async.AsyncPattern<TInput, TMatchResult> class to get the Description property for free, or implement the IAsyncPattern<TInput, TMatchResult> directly. Normal patterns can be turned into async patterns by calling the AsAsync() extension (defined in the Matchmaker.Linq namespace). Async Match Expressions Async match expressions are also very similar to normal match expressions. There are two types of async match expressions: AsyncMatch<TInput, TOutput> which yields a result and AsyncMatch<TInput> which doesn't. They can be created using methods in the AsyncMatch class. The Case methods of async match expressions are overloaded to take either async patterns or normal patterns (which are turned into async patterns using the AsAsync() extension) and to take either async or sync actions to executed when a pattern is matched successfully (sync actions are turned into async actions). Async match expressions can be executed using the ExecuteAsync, ExecuteNonStrictAsync and ExecuteWithFallthroughAsync methods. The ToFunction method and its variations are also available. ExecuteWithFallthroughAsync returns an IAsyncEnumerable which enables lazy async execution of match expressions. The Matchmaker.Linq namespace contains the EnumerateAsync extension method for IAsyncEnumerable<T> which enumerates it and ignores the result. You can use it if you just want to execute the match statement with fall-through. Static async match expressions are also available. Use the AsyncMatch.CreateStatic methods to create them, just like normal match expressions. The methods accept an action on either AsyncMatchBuilder<TInput, TOutput> or AsyncMatchBuilder<TInput>. Static match expressions are globally cached and the caching process is thread-safe. Caches can be cleared with the ClearCache methods in AsyncMatch."
  },
  "articles/expressions.html": {
    "href": "articles/expressions.html",
    "title": "Match Expressions | Matchmaker",
    "summary": "Match Expressions The second central idea is the match expression itself. It is represented by two classes: Match<TInput, TOutput> and Match<TInput>. The difference between them is that the former represents a match expression which yields a result, and the latter represents a match expression which doesn't yield a result (also known as a match statement). Using Match Expressions Creating Match Expressions A match expression can be created using the Create methods of the static class Match. Adding Cases The Match classes include Case methods which are used to add a pattern and a function which is executed if the match is successful. Match expressions are immutable – Case methods return new match expressions; they do not affect the ones on which they are called. Case methods are generic – they also contain information about the pattern's transformation type. Match expressions can contain patterns of arbitrary transformation types without knowing about these types. Executing Match Expressions To execute a match expression, the ExecuteOn method is used. It takes the input value to match. There are two modes of execution in match expressions: strict and non-strict. The strict mode throws an exception if no matches were found, and the non-strict doesn't. In the Match<TInput, TOutput> class, the ExecuteOn method returns the result of the match or throws a MatchException if no successful match was found. Match<TInput, TOutput> also contains the ExecuteNonStrict method which executes the match expression in the non-strict mode. It returns MatchResult<TOutput> because the result might not be present. In the Match<TInput> class, the ExecuteOn method doesn't return anything, and also throws a MatchException if the match wasn't successful. This class also contains the ExecuteNonStrict method – it returns a boolean value which indicates whether the match was successful and doesn't throw an exception if it wasn't. The ToFunction method and its variations are also available. They return a function which, when called, will execute the match expression. Matching with Fall-through C, C++ and, Java support fall-through in switch statements. So does this library, although it works differently here. Fall-through must be explicitly enabled for cases and then explicitly enabled during execution. Both Match classes contain the ExecuteWithFallthrough method which takes fall-through behavior into account. ExecuteOn and ExecuteStrict ignore the fall-through behavior. If a case has fall-through enabled, then the expression falls to the next successful match, unlike switch, which falls to the next case whether it's successful or not. The Case methods are overloaded to accept a boolean value which indicates the fall-through behavior. If fall-through is enabled for a pattern, then the expression will continue searching for the next successful pattern. If it isn't, then the expression will stop at this pattern and not go any further. Match.Create is also overloaded to take the default fall-through behavior. Matching with fall-through is lazy, i.e., it returns an IEnumerable and is only executed when this enumerable is enumerated. Because matching will fall-through is lazy, it doesn't have any modes of execution – the user must decide whether to throw an exception or not if there were no successful matches. In the Match<TInput, TOutput> class, the ExecuteWithFallthrough method returns an IEnumerable<TOutput> which can be used to get all successful match results. In the Match<TInput> class there are no results, so the ExecuteWithFallthrough method returns an IEnumerable<object> which should be used simply to enumerate the match process itself. This is implemented so that matching with fall-through is also lazy in this class. The values of the resulting enumerable don't matter - in fact, they are always null, because match statements don't produce any results. What matters is the process of enumeration. You can use the LINQ's Take method to limit the number of executed matches, or the Count method to execute it and get the number of successful matches. The Matchmaker.Linq namespace contains the Enumerate extension method for IEnumerable<T> which enumerates it and ignores the result. You can use it if you just want to execute the match statement with fall-through. Important Matching with fall-through is lazy and is actually executed when the result is enumerated. Here's a (somewhat convoluted) implementation of the famous fizz-buzz program which uses matching with fall-through: using System.Linq; using Matchmaker; using Matchmaker.Linq; using static Matchmaker.Patterns.Pattern; // ... IPattern<int, int> DivisibleBy(int n) => CreatePattern<int>(input => input % n == 0); var result = Enumerable.Range(0, 15) .Select(Match.Create<int, string>(fallthroughByDefault: true) .Case(DivisibleBy(3), _ => \"Fizz\") .Case(DivisibleBy(5), _ => \"Buzz\") .Case(Not(DivisibleBy(3).Or(DivisibleBy(5))), n => n.ToString()) .ToFunctionWithFallthrough()) .Select(items => items.Aggregate(String.Concat)) .ToList(); // The result is: // \"FizzBuzz\", \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\" Static Match Expressions The Initialization Problem One pain point of match expressions is that whenever a method which contains a match expression is executed, the match expression is initialized from scratch. Take a look at this example: void DoStuff(int i) => Match.Create<int, string>() .Case(...) .Case(...) .Case(...) .Case(...) .ExecuteOn(i); The problem here is that if we call DoStuff 10,000 times, we will initialize the match expression 10,000 times as well, even though it's actually the same expression. Having just 4 cases may not seem like much, but the lag and allocations do accumulate if we execute it thousands of times. We can save the expression in a field and then call the ExecuteOn method on this field. But this makes the code much less readable because the case definitions are in a different place from the actual execution point. The Solution There is a way to create static match expressions – expressions which will be initialized only once. The Match class contains the CreateStatic methods which allow the creation of static match expressions. Take a look at the modified example: void DoStuff(int i) => Match.CreateStatic<int, string>(builder => builder .Case(...) .Case(...) .Case(...) .Case(...)) .ExecuteOn(i); It looks almost the same, except for one difference: the calls to Case methods are inside the lambda expression, called the build action, which is passed to the CreateStatic method. Now this match expression will be initialized only once, and its initialization code is in the same place as its execution point. The parameter of the build action has the type MatchBuilder<TInput, TOutput or MatchBuilder<TInput>, depending on which type of match expressions you are building. This type has the same methods for adding cases as the Match classes and is mutable – the methods return the same builder instance. MatchBuilder also has the Fallthrough method which specifies the default fall-through behavior. But this method specifies fall-through behavior only for cases that are defined after it. For example: builder .Fallthrough(true) .Case(...) // this case has fall-through behavior if not specified otherwise .Case(...) // this case also has fall-through behavior if not specified otherwise .Fallthrough(false) .Case(...) // this case doesn't have fall-through behavior if not specified otherwise .Case(...) // this case also doesn't have fall-through behavior if not specified otherwise Every case can configure its fall-through behavior individually as well. Caching Match Expressions The build action will be called only once, and its result will be cached. The cache is a static hash-table. The caching process is not thread-safe. The key of the cache is the place where the CreateStatic method is called. Apart from the build action, this method also accepts two caller info arguments: the path to the source file and the line in the source file. Users don't need to pass these arguments to the method as they have the CallerFilePath and CallerLineNumber attributes. The Match class also contains the ClearCache methods which clear a global cache. Match expressions have a cache per type (so Match<int, int> uses a different cache than Match<int, string>) so ClearCache only clears one cache. Clearing the cache will force all static match expressions of that type to be reinitialized. This process is not thread-safe as well."
  },
  "articles/migration.html": {
    "href": "articles/migration.html",
    "title": "Migration Guide | Matchmaker",
    "summary": "Migration Guide This article describes how to migrate to version 2.0.0 from PatternMatching v1.2.0. If you need to migrate from older versions, first migrate to version 1.2.0. You can do that just by reading the changelog, because previous versions contained much fewer changes and it's much simpler to migrate. In order to migrate from version 2.0.0 to version 2.1.0, action is required only if you implemented the IPattern<TInput, TMatchResult> interface (which wasn't recommended). The less generic IPattern<TInput> interface was removed, so you should remove its Match method. That's it. No changes are required to migrate from version 2.1.0 to 3.1.0. Version 3.0.0 removed support for .NET Standard 2.0, but version 3.1.0 added it back, effectively undoing its only breaking change. General Since this library has a new name, the namespace is different as well. Instead of the PatternMatching namespace there are three namespaces: Matchmaker, Matchmaker.Patterns and Matchmaker.Linq. The dependency on language-ext was dropped. Instead of using OptionUnsafe this library now uses its own MatchResult. Patterns The predefined patterns haven't changed much, but the way to create custom patterns changed drastically. The Match method in IPattern<TInput, TMatchResult> now returns MatchResult<TMatchResult> instead of OptionUnsafe<TMatchResult>. The IPattern<TInput, TMatchResult> now contains the Description property. If you implemented this interface, you must add it and make it return an empty string if you don't want a description. IPattern<TInput, TMatchResult> now extends IPattern<TInput>. If you implemented this interface, it's better to extend the new Pattern<TInput, TMatchResult> class instead, as it provides both an implementation of the less generic interface, and the Description property. Bear in mind that IPattern<TInput> was removed in version 2.1.0 so don't bother with it much. The ConditionalPattern<TInput, TMatchResult, TPattern> is gone. It's too much work for the users to implement filtering of patterns if they want a highly customized pattern. If you filtered pattern results with the When method before, now you can do that using the Where extension method from the Matchmaker.Linq namespace, which works on all patterns, and doesn't need a special base class. I renamed this method because previously I wanted it to look like the when clause of the switch expressions, but now this method is part of LINQ to Patterns, so Where is more appropriate. SimplePattern<TInput> is gone and Pattern<TInput, TMatchResult> now serves as a base class for patterns. If you need to create a pattern from a function or a predicate, use the CreatePattern methods in the Pattern class. Since SimplePattern<TInput> is gone, you cannot use operators to compose patterns (&, | and ^). Also, the And, Or and Xor methods are not part of pattern definition - they are extension methods from the Matchmaker.Linq namespace. The ~ operator is gone as well. Use Not instead. The StructNull pattern is gone. It was deprecated in version 1.2.0. The ValueNull pattern provides the same functionality. Match Expressions The default mode of execution for match statements is now strict. So ExecuteOn is strict. The ExecuteStrict method is gone and ExecuteNonStrict was added. This was changed because it was unintuitive to have different default modes in match expressions and match statements. Matching with fall-through became lazy. This is major change. The result in match expressions is now not an Lst from language-ext, but a lazy IEnumerable which the user has to enumerate for the match to actually be executed. Match statements also return an IEnumerable instead of a number of successful cases. If you want to know the number of successful cases, you can call Count() on the result of the match. Or you can call Enumerate from Matchmaker.Linq if you just want to execute it. Since matching with fall-though is lazy, it doesn't have modes of execution - it's just non-strict. The library cannot decide to throw an exception if there are no successful cases because the library doesn't decide when to execute the expression."
  },
  "articles/nullable.html": {
    "href": "articles/nullable.html",
    "title": "Nullable Reference Types | Matchmaker",
    "summary": "Nullable Reference Types Starting with version 3.0, support for nullable reference types (NRTs) is enabled. Support for NRTs is limited in this library because it uses generics extensively, and generics don't play nicely with NRTs. Note On .NET Standard 2.0, support for NRTs is even more limited, since attributes for null-state static analysis are not available, and Matchmaker simply elides them on this TFM instead of using a polyfill. Since match expressions can work will null, their return types are marked as such. Match results may also contain null values. This may be inconvenient if you know that null values are not used as match results. In addition, extensions in Matchmaker.Linq also don't fully support NRTs. Look at the (simplified) implementation of the Select extension for match results: public static MatchResult<TResult> Select<T, TResult>(this MatchResult<T> result, Func<T, TResult> mapper) => result.IsSuccessful ? MatchResult.Success(mapper(result.Value!)) : MatchResult.Failure<TResult>(); Here's the interesting part: mapper(result.Value!). There is no way to tell C# that mapper can receive null inputs, because T is generic and we cannot use T?. Since extensions for patterns use extensions for match results, this also applies to extensions for patterns. There is no way to tell C# that functions passed to those extensions can receive null, but they can, and this should be accounted for. When using this library with NRTs enabled, remember two things: MatchResult<T> may contain null and so patterns can return null as their results as well Match expressions' results may be null"
  },
  "articles/patterns.html": {
    "href": "articles/patterns.html",
    "title": "Patterns | Matchmaker",
    "summary": "Patterns One of two central ideas of this library is a pattern. Patterns are used to match the input value against a certain 'shape'. For example, 'the input value is equal to some value' or 'the input value has some type'. The IPattern<TInput, TMatchResult> interface A pattern is an object which implements the Matchmaker.Patterns.IPattern<TInput, TMatchResult> interface. This interface contains two members: string Description { get; } MatchResult<TMatchResult> Match(Tinput input); The Match method actually does two things: Matches the input value with the pattern and returns a successful result if the match is successful. Transforms the input value. The returned result contains the transformed value if it's successful. Since options are not supported natively in C#, a custom type – MatchResult<T> – is used. The definition of patterns is similar to F#'s active patterns. Descriptions for patterns are not terribly important, but can be useful for debugging. As such, they are optional – if you don't want a pattern to have a description, it should be empty. A pattern's description should never be null. Null Values The results of patterns' matching can be null. This is why the MatchResult<T> type can contain a null value. Using Predefined Patterns There are several predefined patterns in the Matchmaker.Patterns.Pattern class: Any is always matched successfully and returns its input. Return is also always matched successfully but returns the specified value instead of its input. Null is matched successfully if its input is null. ValueNull is also matched successfully if its input is null, but is used for nullable value types. EqualTo is matched successfully if its input is equal to the specified value. LessThan, LessOrEqual, GreaterThan and GreaterOrEqual are matched successfully if their input is compared successfully to the specified value. Type is matched successfully if its input has the specified type. It returns its input as a value of that type. If the input is null, then the match will fail only if the destination type is a non-nullable value type. Not is matched successfully if the specified pattern is not matched successfully. It ignores the specified pattern's transformation and returns its input if matched successfully. The patterns which compare their inputs can also take a custom comparer which will be used to compare values. The patterns that take a value can also take a value provider (a function which returns the value) in order to lazily match the input. The value provider will be called once upon the first call to the Match method and then its result will be cached. Note that the caching process is not thread-safe. All methods for getting predefined patterns are overloaded to take a custom description. LINQ to Patterns The Matchmaker.Linq namespace provides several extension methods for patterns: Select maps a pattern's result value if it's successful. Pipe creates a pattern pipeline – the result of the first pattern is the input of the second pattern. Cast casts a pattern's result to a specified type. It's the same as piping a pattern to the Type pattern. If the input is null, then the match will fail only if the destination type is a non-nullable value type. Bind flat-maps a pattern's result. If a pattern's result is successful, it calls the specified function and passes the result to it. The function returns another pattern which is then used to match the input. The second pattern's result is the final result. Where filters the pattern's result if it's successful. And, Or and Xor compose two patterns. The resulting pattern ignores the patterns' transformations and returns the input if successful. Compose is the same as the three methods above, but the composition operator is passed to it as well. Cached returns a pattern which matches the same as the specified pattern but caches its results in a null-safe hash table. Every input will be matched only once – if it's matched again, the result will be taken from the cache. The caching process is not thread-safe. All extension methods for patterns are overloaded to take a custom description. Since there are the Select and Where extensions on patterns, you can write them using C#'s query syntax. Patterns have the Bind and Return functions, so they are monads. To be more specific, patterns can be thought of as a combination of the Reader and Maybe monads. Immutability All predefined patterns, as well as patterns returned by CreatePattern and extension methods, are immutable. Calling an extension method on a pattern returns a new pattern – the old one is unchanged. An exception is the pattern returned by the Cached method, which is not immutable – it holds a mutable cache. But if a pattern is referentially transparent (its Match method always returns the same result for the same input and doesn't have any side effects), then the caching pattern based on it can be thought of as immutable as well, because it doesn't matter how many times the base pattern's Match method is called. Creating Custom Patterns This library works with arbitrary patterns. There are several ways to create custom patterns. The Easy Way The Pattern class contains the CreatePattern methods which create patterns from functions. There are two variations: Create a pattern from a predicate. This predicate will be used to test the value. If it returns true, then the input value will be the result. Create a pattern from a matcher function. This is a function which has the same signature as the Match method of the IPattern<TInput, TMatchResult> interface. This function will be used to match inputs. There are also overloads which take a description. The Hard Way If you want something more complex than a single function, you can create a class which extends the Matchmaker.Patterns.Pattern<TInput, TMatchResult> class. This is a base class for patterns, and it implements the Description property which you don't have to use if you don't want – by default the description is empty, which means that the pattern doesn't have a description. You can also implement the IPattern<TInput, TMatchResult> interface directly. There is no reason to do that instead of extending the Pattern<TInput, TMatchResult> class unless your class already extends another class. But in that case, making your class a pattern will most probably break the single responsibility principle."
  },
  "articles/results.html": {
    "href": "articles/results.html",
    "title": "Match Results | Matchmaker",
    "summary": "Match Results This library has to deal with values that sometimes might be present, and sometimes not. This can be represented by the 'optional value' pattern. Unfortunately, C# does not have a native optional type. The 1.x versions of this library used language-ext to include the optional type. There are several reasons why this library was dropped in version 2: language-ext is a full-blown framework for functional programming. Users may not want that much functionality. They may want just pattern matching and nothing else. Users may use a different library/framework for functional features. There are a lot of those for C#. So, starting with version 2, instead of using the OptionUnsafe<T> type from language-ext, this library includes a MatchResult<T> type. This type works much like optional types from other libraries in that it may contain a value, or may not, except for a couple differences: MatchResult<T> is not a general-purpose optional type and shouldn't be used as such. MatchResult<T> can contain null values and this is important to remember. This type is not used to avoid NullReferenceException. Working with Match Results MatchResult<T> is a struct with value-based equality. Values of this type can be created through methods in the MatchResult class: Success and Failure. The simplest way to work with match results is to use the IsSuccessful and Value properties. Value throws an exception if the result doesn't contain a value. If you are using a functional library/framework, you can write an extension method which transforms MatchResult<T> into the library's optional type. But remember that MatchResult<T> can contain null values, and not all optional implementations support that. LINQ to Results The Matchmaker.Linq namespace contains several extension methods to make working with match results easier: GetValueOrDefault lets you safely get the value of the result. GetValueOrThrow lets you get the value of the result or explicitly throw an exception of your choice. Select maps the value of the result if it's present. Bind flat-maps the value of the result if it's present. Where filters the result's value if it's present. Cast casts the result's value to the specified type if it's present and can be cast to that type. Note that null values cannot be cast to a non-nullable value type, and if a successful result which contains a null value is cast to a non-nullable value type, you will get a failed result. Do performs an action on the result's value if it's present and returns the result itself. Since there are the Select and Where extensions on MatchResult<T>, you can write them using C#'s query syntax."
  },
  "articles/unions.html": {
    "href": "articles/unions.html",
    "title": "Discriminated Unions | Matchmaker",
    "summary": "Discriminated Unions While discriminated unions (or sum types) are not directly supported in C# as of June 2025, they can be modelled using class hierarchies. But in order for them be user-friendly, a way to process the values has to be implemented, e.g., in the form of the Visitor pattern. Or, pattern matching can be used instead. Let's define a simple list, implemented as cons cells. This list is not generic for simplicity. public abstract class ConsList { private protected ConsList() { } public static ConsList Cell(int head, ConsList tail) => new ConsCell(head, tail); public static ConsList Empty => new Empty(); } public sealed class ConsCell : ConsList { public int Head { get; } public ConsList Tail { get; } internal ConsCell(int head, ConsList tail) { this.Head = head; this.Tail = tail; } } public sealed class Empty : ConsList { internal Empty() { } } Now let's look what pattern matching on the list would look like. Let's create a function which finds the sum of all items of the list. public int Sum(ConsList list) => Match.Create<ConsList, int>() .Case<ConsCell>(cell => cell.Head + Sum(cell.Tail)) .Case<Empty>(_ => 0) .ExecuteOn(list); Case<TType>(...) is the same as Case(Pattern.Type<TInput, TType>(), ...). Here is the equivalent function implemented using the switch statement (pre-C# 8): public int Sum(ConsList list) { switch (list) { case ConsCell cell: return cell.Head + Sum(cell.Tail); case Empty _: return 0; } throw new MatchException(\"This will never happen, but C# can't know that.\"); } As you can see, we have to throw an exception in the switch version, because C# can't know that ConsCell and Empty are the only possible subclasses of ConsList. And for that reason, if we forget to define one of the cases in switch or in a match, we'll get an exception. In F#, a warning is issued when the match is incomplete, but C# doesn't have the notion of complete or incomplete matches. Of course, this match will fail if the provided list is null, but this can be handled using the Null pattern. With C# 8, there's a better way to match on discriminated unions, but we still have to explicitly throw an exception in the default case (which we know won't happen): public int Sum(ConsList list) => list switch { ConsCell cell => cell.Head + Sum(cell.Tail), Empty _ => 0, _ => throw new MatchException(\"This will never happen, but C# can't know that.\"); }; }"
  },
  "articles/why.html": {
    "href": "articles/why.html",
    "title": "Why This Library Was Written | Matchmaker",
    "summary": "Why This Library Was Written Should I Use This Library? Pattern matching as a technique was created to make code which operates on data more succinct, clear, and readable. I have to say, I'm not sure this library achieves this. There's no denying that this library is cumbersome, and some features are kind of convoluted. You can certainly use it if you want to – it's extensively tested. But this is more of an experimental effort – I wanted to see how powerful pattern matching can be in C#. In this article I'll try to explain some reasons behind the features of this library. This is not documentation per se, it's more of a thought piece about this library and a recap of its history. Also, I should note that I haven't checked out any other pattern matching libraries for C#. I'm sure there are a lot of them – I can't be the only one who tried to bring this technique into C#. But I wanted to create something by myself and not get inspired by (read: steal) features from the other libraries as I'm sure there's not actually much space for stretching here. Some pattern matching libraries are probably better than this one and I'm okay with it. Background In the end of 2017, after studying F# and functional programming, I've decided to try to bring some functional features into C#. I've created a small library for C# and named it CSX – C# Extensions. I worked on this library just for the fun of it and never intended for it to be anything serious. I've long since stopped doing anything with it, because I've realized that it required a lot of work. My implementations of functional data structures were quite naive, and I've decided that I don't want to invest time into optimizing them. Moreover, I was discouraged by the fact that there already are great functional libraries out there, like language-ext. One feature from that library grew into something more: pattern matching. I've included it into CSX and tried to create a simple way to implement pattern matching on arbitrary types through interfaces, but failed and realized that it can't be done that way. I came up with a different way to do pattern matching on arbitrary types, but decided to implement it separately from CSX. This is how the PatternMatching library was born. PatternMatching I released the first version of PatternMatching in October 2018. It contained the bare minimum. Patterns are just objects which implement an interface. A match expression is just an object as well. Internally the data about cases was stored as dynamic because the match expression itself cannot know about the types of patterns' transformations. I thought that was the only way to do that. Well, that or reflection. Boy was I wrong, but more on that later. The only reason I've chosen the DLR instead of reflection was because it's easier to write code this way. I've done little research about the performance comparison between the two approaches. Since the name PatternMatching was already taken on NuGet, I've decided to name the package CSharpStuff.PatternMatching (not my best decision). Almost immediately after releasing version 1.0, I made some changes. Some of them were breaking. I know that breaking changes require a bump of the major version, but I didn't think those changes were big enough to warrant a bump of the major version. Also, a breaking change is only breaking if someone actually uses the code. The one big change in version 1.1 was introduction of matching with fall-through. This is probably the most 'experimental' feature in the library. I understand that matching with fall-through probably makes code more difficult to comprehend, but it was fun to play around with designing this feature. It includes major design deviations from the established way of fall-through that's present in C, C++, and Java. C# doesn't have fall-through at all and I think it's a good thing because the way it's implemented in those languages can lead to subtle errors. I understand why it works this way, but the probability of making an error and letting code fall through to the next case is quite big (I should know, I've done that mistake myself). That is why I've implemented it in a way that lets code fall through to the next successful case, and it should be explicitly enabled in several places. I can't really say whether it's better or worse than how switch works, but for me it makes at least the tiniest bit of sense. After releasing version 1.1 (also in October 2018), I thought that that was it and didn't return to it for a year. But version 1.1 was untested, and I knew that I needed to add tests to make this library usable. After I started adding tests, I realized that it was really unusable. Matching with fall-through didn't work at all. Adding tests proved more difficult that I initially thought, simply because adding hundreds of them is not really fun. I decided to use FsCheck (which is for F# but can be used with C# as well) to write property-based tests. I wanted my tests not just to test the functionality, but also to serve as additional documentation which precisely describes the properties of classes and methods. Version 1.2 is the tested version of 1.1. Nobody should use versions 1.0 and 1.1. During the development of version 1.2 I came up with more ideas for improvement of PatternMatching. I also came up with a better name for the library (PatternMatching is a lame name). Matchmaker I've decided to rename the library to 'Matchmaker'. This makes it a triple pun on the word 'match' (Matchmaker does pattern matching, and its logo is a match). Even though there were a lot of breaking changes between these versions, and the library name is different, I believe this is still the same library, because it stayed the same at its core. After releasing version 1.2, it came to me how to implement type-ignorant matching without the use of neither the DLR nor reflection. And to be honest, at that moment I felt dumb, because I haven't thought about it before, and the solution was obvious. In this version, I've also completely uprooted the pattern hierarchy and made working with them much easier. I've also added some primitive caching. I'm not an expert on caching – this can be an extensive topic of research – so I can't say that caching in this library is great – it's okay at best. If you need more extensive or better caching of match expressions, you can create an issue (or better yet, a pull request) on GitHub. I will most definitely respond and will do my best to implement it. I've improved the performance of match expression initializations by making them static. This makes the code even more cumbersome, but as for me, it's worth it. One other thing that I've changed drastically is matching with fall-through. The reasoning behind it was shaky before, and now it must seem even more weird. I've made it lazy, which makes it more powerful in that the user can, for example, limit the number of executed cases, but it became even more cumbersome to use. I've also realized that having different default modes of execution in match expressions and match statements was unintuitive, so now match statements also match strictly by default. A couple days after releasing version 2.0.0 I realized once again that I was being dumb and that the less generic IPattern<TInput> interface was not needed. And when I removed it, the only possible point of type failure was gone. Once again, even though this change is potentially breaking, I didn't bump the major version, because I don't think it would break any actual code. After releasing version 2.1.0, I started working on version 3.0.0 which contains 2 major additions: support for nullable reference types and asynchronous pattern matching. Because of those additions, the .NET Standard version had to be bumped to 2.1 (sorry, .NET Framework). Asynchronous pattern matching will probably not be used often. I wrote it simply because I can, and why not – we have asynchronous enumeration, asynchronous disposal, asynchronous almost everything, so why not asynchronous pattern matching? Five years after releasing version 3.0.0, I've decided to release version 3.1.0 which adds support for .NET Standard 2.0 back and uses Microsoft.Bcl.AsyncInterfaces as the polyfill for asynchronous interfaces. So now the library supports .NET Framework once again. So Why Was This Library Written? Having recapped some history and explained some design decisions, I haven't actually said why I wrote this library. Well, the answer is simple: I wrote this library to write a library. I wanted to know what this process is like. Write code. Build it. Deploy it to NuGet. See people actually download it, even though it's a small number. Write tests. A lot of tests. Test everything. There are more tests than lines of code that are actually tested. Write documentation. Lots of it. There's more documentation than code in this library. Write articles on how to use this library. All of this is a lot of work, and this is an exceedingly small library. But I really wanted it to be extensively tested and documented. I know what it's like when you want to use a library and the only way of doing that is to browse its source code. It's not fun. In the process of writing this library I've gained more appreciation of people that maintain libraries. I realize now just how much work this actually is. What's Next I'm not planning on writing new versions beyond 3.1. To be fair, I thought the same thing after releasing version 1.1 and yet here we are. This time I do believe that this library has enough features (probably more than enough). Maybe one day I'll revisit this decision, but for now (June 2025) this is it; this is as good as it gets."
  },
  "index.html": {
    "href": "index.html",
    "title": "Introduction | Matchmaker",
    "summary": "Introduction Matchmaker is a library which enables more powerful pattern matching than is currently available in the C#'s switch statement/expression. Installation dotnet add package Matchmaker A Simple Example This is what the simplest match expression looks like: using static Matchmaker.Patterns.Pattern; // ... string result = Match.Create<int, string>() .Case(EqualTo(1), _ => \"one\") .Case(EqualTo(2), _ => \"two\") .Case(EqualTo(3), _ => \"three\") .Case(EqualTo(4), _ => \"four\") .Case(Any<int>(), i => i.ToString()) .ExecuteOn(5); EqualTo is a predefined pattern. This is what an equivalent switch statement looks like (pre-C# 8): string result; int i = 5; switch (i) { case 1: result = \"one\"; break; case 2: result = \"two\"; break; case 3: result = \"three\"; break; case 4: result = \"four\"; break; default: result = i.ToString(); break; } While this example doesn't show the full power of pattern matching, there are a few things to note here: The match expression yields a result. We don't have to assign the result explicitly in each case. The input of the match expression is specified after all the cases. This allows us to save the match expression in an object and use it multiple times on different input values. The default case is a pattern, just like any other. It's called Any and is always matched successfully. Like in switch, the patterns are tried out sequentially. This means that the Any pattern should always come last. C# 8 included a new way to write switch expressions which yield a value, and further versions extended it quite a bit. This drastically reduced the need for external libraries like this one for pattern matching. However, this library lets the user define arbitrary patterns which makes this library more powerful than the switch expression. Here's what the equivalent switch expression looks like in C# 8: int i = 5; string result = i switch { 1 => \"one\", 2 => \"two\", 3 => \"three\", 4 => \"four\", _ => i.ToString() }; OK, this is much shorter and cleaner than the previous two examples. But this library shines when the patterns are more complex. While C# allows various kinds of patterns, this library allows anything you can think of. More Info If you want to learn how to use this library, you should read these articles. They provide everything you need to know to use this library. If you need extensive information, go to the API reference. If you need even more info about this library, you can go through the tests. They are property-based and as such, they describe every aspect of the classes and their members. They cover 100% of this library's code (except the MatchException class which is trivial)."
  }
}